{
  "language": "Solidity",
  "sources": {
    "OliveNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract OliveNFT is ERC721Enumerable, Ownable, ReentrancyGuard {\n    using Strings for uint256;\n\n    uint256 public constant MAX_SUPPLY = 20000;\n    uint256 public constant MINT_PRICE = 0.005 ether;\n\n    bool public saleActive;\n    bool public revealed;\n    string private baseURI_;\n    string public unrevealedURI;\n\n    uint16[] private _typeCounts;\n    bool public typeCountsFrozen;\n\n    bytes32 public metadataSeedCommit;\n    bytes32 public metadataSeed;\n    uint256 public metadataOffset;\n\n    bool public enforceOnePerAddress = true;\n    uint256 private _nextTokenId = 1;\n\n    event SaleStateSet(bool active);\n    event BaseURISet(string baseURI);\n    event UnrevealedURISet(string uri);\n    event MetadataCommit(bytes32 commitHash);\n    event MetadataReveal(bytes32 seed, uint256 offset);\n    event TypeCountsSet(uint16[] counts);\n    event TypeCountsFrozen();\n    event EnforceOnePerAddressSet(bool enforce);\n    event Withdraw(address indexed to, uint256 amount);\n\n    error SaleNotActive();\n    error SoldOut();\n    error WrongPrice();\n    error AlreadyCommitted();\n    error NotCommitted();\n    error AlreadyRevealed();\n    error InvalidSeed();\n    error TypesFrozen();\n    error TypesNotSet();\n    error BadTypeSum();\n    error AlreadyHolding();\n\n    constructor(\n        string memory _name,\n        string memory _symbol,\n        string memory _unrevealedURI\n    ) ERC721(_name, _symbol) Ownable(msg.sender) {\n        unrevealedURI = _unrevealedURI;\n    }\n\n    function setSaleActive(bool _active) external onlyOwner {\n        saleActive = _active;\n        emit SaleStateSet(_active);\n    }\n\n    function setEnforceOnePerAddress(bool v) external onlyOwner {\n        enforceOnePerAddress = v;\n        emit EnforceOnePerAddressSet(v);\n    }\n\n    function setTypeCounts(uint16[] calldata counts) external onlyOwner {\n        if (typeCountsFrozen) revert TypesFrozen();\n        uint256 sum = 0;\n        for (uint256 i = 0; i < counts.length; ++i) {\n            sum += counts[i];\n        }\n        if (sum != MAX_SUPPLY) revert BadTypeSum();\n        delete _typeCounts;\n        _typeCounts = counts;\n        emit TypeCountsSet(counts);\n    }\n\n    function freezeTypeCounts() external onlyOwner {\n        typeCountsFrozen = true;\n        emit TypeCountsFrozen();\n    }\n\n    function commitMetadataSeed(bytes32 commitHash) external onlyOwner {\n        if (metadataSeedCommit != bytes32(0)) revert AlreadyCommitted();\n        metadataSeedCommit = commitHash;\n        emit MetadataCommit(commitHash);\n    }\n\n    function revealMetadata(bytes32 seed, string calldata newBaseURI) external onlyOwner {\n        if (_typeCounts.length == 0) revert TypesNotSet();\n        if (metadataSeedCommit == bytes32(0)) revert NotCommitted();\n        if (revealed) revert AlreadyRevealed();\n        if (keccak256(abi.encodePacked(seed)) != metadataSeedCommit) revert InvalidSeed();\n\n        metadataSeed = seed;\n        metadataOffset = uint256(keccak256(abi.encode(seed, address(this)))) % MAX_SUPPLY;\n        revealed = true;\n        _setBaseURI(newBaseURI);\n        emit MetadataReveal(seed, metadataOffset);\n    }\n\n    function setUnrevealedURI(string calldata uri) external onlyOwner {\n        unrevealedURI = uri;\n        emit UnrevealedURISet(uri);\n    }\n\n    function setBaseURI(string calldata uri) external onlyOwner {\n        _setBaseURI(uri);\n    }\n\n    function _setBaseURI(string calldata uri) internal {\n        baseURI_ = uri;\n        emit BaseURISet(uri);\n    }\n\n    function mint() external payable nonReentrant {\n        if (!saleActive) revert SaleNotActive();\n        if (totalSupply() >= MAX_SUPPLY) revert SoldOut();\n        if (msg.value != MINT_PRICE) revert WrongPrice();\n        if (enforceOnePerAddress && balanceOf(msg.sender) != 0) revert AlreadyHolding();\n        _safeMint(msg.sender, _nextTokenId);\n        unchecked { _nextTokenId += 1; }\n    }\n\n    function ownerMint(address to, uint256 quantity) external onlyOwner {\n        uint256 supply = totalSupply();\n        require(supply + quantity <= MAX_SUPPLY, \"Exceeds max\");\n        uint256 tokenId = _nextTokenId;\n        unchecked {\n            for (uint256 i = 0; i < quantity; ++i) {\n                _safeMint(to, tokenId++);\n            }\n            _nextTokenId = tokenId;\n        }\n    }\n\n    function _F8(uint16 r, uint256 round) internal view returns (uint16) {\n        return uint16(uint256(keccak256(abi.encode(metadataSeed, round, r))) & 0xFF);\n    }\n\n    function _feistel16(uint16 x) internal view returns (uint16) {\n        uint16 L = x >> 8;\n        uint16 R = x & 0xFF;\n        unchecked {\n            for (uint256 round = 0; round < 4; ++round) {\n                uint16 newL = R;\n                uint16 newR = L ^ _F8(R, round);\n                L = newL & 0xFF;\n                R = newR & 0xFF;\n            }\n        }\n        return (L << 8) | R;\n    }\n\n    function _scatterIndex(uint256 v) internal view returns (uint256) {\n        uint16 x = uint16(v);\n        uint16 y = _feistel16(x);\n        while (y >= MAX_SUPPLY) {\n            y = _feistel16(y);\n        }\n        return uint256(y);\n    }\n\n    function tokenType(uint256 tokenId) public view returns (uint256) {\n        _requireOwned(tokenId);\n        if (!revealed) return 0;\n        uint256 gidx0 = _scatterIndex(tokenId - 1);\n        uint256 gidx1 = gidx0 + 1;\n        uint256 running = 0;\n        uint256 n = _typeCounts.length;\n        for (uint256 t = 0; t < n; ++t) {\n            running += _typeCounts[t];\n            if (gidx1 <= running) {\n                return t + 1;\n            }\n        }\n        return 0;\n    }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\n        _requireOwned(tokenId);\n        if (!revealed) return unrevealedURI;\n        uint256 tIndex = tokenType(tokenId);\n        require(tIndex != 0, \"type not found\");\n        return string.concat(baseURI_, tIndex.toString(), \".json\");\n    }\n\n    function getTypeCounts() external view returns (uint16[] memory) {\n        return _typeCounts;\n    }\n\n    function withdraw(address payable to) external onlyOwner nonReentrant {\n        require(to != address(0), \"zero address\");\n        uint256 bal = address(this).balance;\n        emit Withdraw(to, bal);\n        Address.sendValue(to, bal);\n    }\n\n    receive() external payable { revert(\"send ETH via mint()\"); }\n    fallback() external payable { revert(\"send ETH via mint()\"); }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": ["abi", "evm.bytecode", "evm.deployedBytecode", "metadata"]
      }
    }
  }
}
